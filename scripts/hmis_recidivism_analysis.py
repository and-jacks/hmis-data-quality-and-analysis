import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import os

# Load the data (assuming it's been generated by the previous script)
data_dir = "hmis_synthetic_data"

clients = pd.read_csv(f"{data_dir}/clients.csv")
enrollments = pd.read_csv(f"{data_dir}/enrollments.csv")
projects = pd.read_csv(f"{data_dir}/projects.csv")
living_situation = pd.read_csv(f"{data_dir}/living_situation.csv")

# Convert date columns to datetime
enrollments['EntryDate'] = pd.to_datetime(enrollments['EntryDate'])
enrollments['ExitDate'] = pd.to_datetime(enrollments['ExitDate'])
clients['DOB'] = pd.to_datetime(clients['DOB'])

# Merge project information
enrollments = enrollments.merge(
    projects[['ProjectID', 'ProjectName', 'ProjectType']], 
    on='ProjectID', how='left'
)

# Create destination and prior situation categories (copied from main analysis)
def categorize_situation(code):
    if pd.isna(code):
        return "Unknown/Still in program"
    
    # Permanent Housing
    if code in [410, 435, 421, 411, 422, 423, 426]:
        return "Permanent Housing"
    
    # Temporary Housing
    elif code in [302, 329, 314, 332, 312, 313, 336, 335]:
        return "Temporary Housing"
    
    # Institutional
    elif code in [215, 206, 207, 225, 204, 205]:
        return "Institutional"
    
    # Homeless
    elif code in [116, 101, 118]:
        return "Homeless"
    
    # Other/Unknown
    else:
        return "Other/Unknown"

# Add categories
enrollments['DestinationCategory'] = enrollments['Destination'].apply(categorize_situation)

# Merge living situation
enrollments = enrollments.merge(
    living_situation[['EnrollmentID', 'LivingSituation']], 
    on='EnrollmentID', how='left'
)

enrollments['PriorSituationCategory'] = enrollments['LivingSituation'].apply(categorize_situation)

# Create a folder for plots
os.makedirs('plots', exist_ok=True)

# ==========================================
# RECIDIVISM ANALYSIS
# ==========================================
def analyze_recidivism():
    """
    Analyze patterns of returns to homelessness (recidivism) 
    and multiple program enrollments
    """
    print("\n===== RECIDIVISM ANALYSIS =====\n")
    
    # Sort enrollments by client and entry date
    enrollments_sorted = enrollments.sort_values(['PersonalID', 'EntryDate'])
    
    # Count enrollments per client
    enrollment_counts = enrollments_sorted.groupby('PersonalID').size().reset_index(name='EnrollmentCount')
    
    # Distribution of enrollment counts
    enrollment_dist = enrollment_counts['EnrollmentCount'].value_counts().sort_index()
    
    print("DISTRIBUTION OF ENROLLMENT COUNTS PER CLIENT:")
    for count, freq in enrollment_dist.items():
        percent = (freq / len(enrollment_counts)) * 100
        print(f"  {count} enrollment(s): {freq} clients ({percent:.1f}%)")
    
    plt.figure(figsize=(12, 6))
    enrollment_dist.plot(kind='bar')
    plt.title('Distribution of Enrollment Counts per Client')
    plt.xlabel('Number of Enrollments')
    plt.ylabel('Number of Clients')
    plt.tight_layout()
    plt.savefig('plots/enrollment_counts_distribution.png')
    
    # Identify clients with multiple enrollments
    multi_enrollment_clients = enrollment_counts[enrollment_counts['EnrollmentCount'] > 1]['PersonalID'].tolist()
    
    print(f"\nTotal clients with multiple enrollments: {len(multi_enrollment_clients)} ({len(multi_enrollment_clients)/len(enrollment_counts)*100:.1f}% of all clients)")
    
    # For clients with multiple enrollments, calculate time between enrollments
    time_between_enrollments = []
    returns_to_homelessness = []
    
    for client_id in multi_enrollment_clients:
        client_enrollments = enrollments_sorted[enrollments_sorted['PersonalID'] == client_id].copy()
        
        # Skip if there's only one enrollment (shouldn't happen given our filter)
        if len(client_enrollments) <= 1:
            continue
        
        # Process each pair of consecutive enrollments
        for i in range(len(client_enrollments) - 1):
            current = client_enrollments.iloc[i]
            next_enrollment = client_enrollments.iloc[i + 1]
            
            # Skip if current enrollment hasn't ended
            if pd.isna(current['ExitDate']):
                continue
            
            # Calculate days between exit and next entry
            days_between = (next_enrollment['EntryDate'] - current['ExitDate']).days
            
            time_between_enrollments.append({
                'PersonalID': client_id,
                'ExitDate': current['ExitDate'],
                'NextEntryDate': next_enrollment['EntryDate'],
                'DaysBetween': days_between,
                'ExitDestination': current['DestinationCategory'],
                'NextProjectType': next_enrollment['ProjectType']
            })
            
            # Check if this is a return to homelessness
            # Consider it a return if client exited to permanent housing 
            # and returned to homeless program within 2 years
            if current['DestinationCategory'] == 'Permanent Housing' and days_between <= 730:
                returns_to_homelessness.append({
                    'PersonalID': client_id,
                    'ExitDate': current['ExitDate'],
                    'ReturnDate': next_enrollment['EntryDate'],
                    'DaysToReturn': days_between,
                    'ExitDestination': current['Destination'],
                    'ReturnProjectType': next_enrollment['ProjectType']
                })
    
    # Convert to dataframes
    if time_between_enrollments:
        time_between_df = pd.DataFrame(time_between_enrollments)
        
        # Summary statistics on time between enrollments
        print("\nTIME BETWEEN PROGRAM ENROLLMENTS (DAYS):")
        time_stats = time_between_df['DaysBetween'].describe()
        for stat, value in time_stats.items():
            print(f"  {stat}: {value:.1f}")
        
        # Distribution of time between enrollments
        plt.figure(figsize=(12, 6))
        sns.histplot(time_between_df['DaysBetween'], bins=30, kde=True)
        plt.title('Days Between Program Enrollments')
        plt.xlabel('Days')
        plt.ylabel('Frequency')
        plt.axvline(time_between_df['DaysBetween'].median(), color='red', linestyle='--', 
                   label=f'Median: {time_between_df["DaysBetween"].median():.0f} days')
        plt.legend()
        plt.tight_layout()
        plt.savefig('plots/days_between_enrollments.png')
        
        # Time between enrollments by exit destination category
        plt.figure(figsize=(12, 6))
        sns.boxplot(x='ExitDestination', y='DaysBetween', data=time_between_df)
        plt.title('Days Between Enrollments by Previous Exit Destination')
        plt.xlabel('Exit Destination')
        plt.ylabel('Days Until Next Enrollment')
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig('plots/days_between_by_destination.png')
    else:
        print("No clients with time between enrollments found.")
    
    # Analyze returns to homelessness
    if returns_to_homelessness:
        returns_df = pd.DataFrame(returns_to_homelessness)
        
        print(f"\nCLIENTS RETURNING TO HOMELESSNESS AFTER PERMANENT HOUSING:")
        print(f"  Total clients returning within 2 years: {len(returns_df)}")
        
        # Returns by time intervals
        intervals = {
            '0-90 days': (0, 90),
            '91-180 days': (91, 180),
            '181-365 days': (181, 365),
            '366-730 days': (366, 730)
        }
        
        print("\nRETURNS TO HOMELESSNESS BY TIME INTERVAL:")
        for label, (min_days, max_days) in intervals.items():
            count = ((returns_df['DaysToReturn'] >= min_days) & 
                     (returns_df['DaysToReturn'] <= max_days)).sum()
            percent = (count / len(returns_df)) * 100
            print(f"  {label}: {count} clients ({percent:.1f}%)")
        
        # Visualize returns to homelessness
        returns_by_interval = []
        for label, (min_days, max_days) in intervals.items():
            count = ((returns_df['DaysToReturn'] >= min_days) & 
                     (returns_df['DaysToReturn'] <= max_days)).sum()
            returns_by_interval.append({'Interval': label, 'Count': count})
        
        returns_by_interval_df = pd.DataFrame(returns_by_interval)
        
        plt.figure(figsize=(10, 6))
        sns.barplot(x='Interval', y='Count', data=returns_by_interval_df)
        plt.title('Returns to Homelessness After Permanent Housing Exit')
        plt.xlabel('Time Since Exit')
        plt.ylabel('Number of Clients')
        plt.tight_layout()
        plt.savefig('plots/returns_to_homelessness.png')
    else:
        print("No returns to homelessness found.")
    
    return {
        'enrollment_counts': enrollment_counts,
        'time_between_enrollments': time_between_df if 'time_between_df' in locals() else None,
        'returns_to_homelessness': returns_df if 'returns_df' in locals() else None
    }

# ==========================================
# CHRONIC HOMELESSNESS ANALYSIS
# ==========================================
def analyze_chronic_homelessness():
    """
    Analyze patterns related to chronic homelessness
    """
    print("\n===== CHRONIC HOMELESSNESS ANALYSIS =====\n")
    
    # Merge living situation data to get months homeless info
    enrollments_with_history = enrollments.merge(
        living_situation[['EnrollmentID', 'TimesHomelessPastThreeYears', 'MonthsHomelessPastThreeYears']],
        on='EnrollmentID', how='left'
    )
    
    # Based on HUD definition, identify likely chronic homeless
    # Chronic = disabled + homeless for 12+ months or 4+ times in 3 years
    def is_chronic(row):
        if row['DisablingCondition'] != 1:
            return False
        
        # Check months homeless (code 113 = more than 12 months)
        if row['MonthsHomelessPastThreeYears'] == 113:
            return True
        
        # Check times homeless (code 4 = four or more times)
        if row['TimesHomelessPastThreeYears'] == 4:
            return True
        
        return False
    
    enrollments_with_history['IsChronicHomeless'] = enrollments_with_history.apply(is_chronic, axis=1)
    
    # Count of chronic homeless clients
    chronic_count = enrollments_with_history['IsChronicHomeless'].sum()
    chronic_percent = (chronic_count / len(enrollments_with_history)) * 100
    
    print(f"CHRONIC HOMELESSNESS PREVALENCE:")
    print(f"  Clients meeting chronic homelessness criteria: {chronic_count} ({chronic_percent:.1f}% of all enrollments)")
    
    # Chronic homelessness by project type
    chronic_by_project = enrollments_with_history.groupby('ProjectType')['IsChronicHomeless'].mean() * 100
    
    print("\nCHRONIC HOMELESSNESS BY PROJECT TYPE:")
    for project_type, percent in chronic_by_project.items():
        project_name = {
            0: 'Emergency Shelter - Entry Exit',
            1: 'Emergency Shelter - Night-by-Night',
            2: 'Transitional Housing',
            3: 'PH - Permanent Supportive Housing',
            13: 'PH - Rapid Re-Housing'
        }.get(project_type, f'Other ({project_type})')
        
        print(f"  {project_name}: {percent:.1f}%")
    
    # Chronic homelessness by year
    enrollments_with_history['EntryYear'] = enrollments_with_history['EntryDate'].dt.year
    chronic_by_year = enrollments_with_history.groupby('EntryYear')['IsChronicHomeless'].mean() * 100
    
    print("\nCHRONIC HOMELESSNESS TRENDS BY YEAR:")
    for year, percent in chronic_by_year.items():
        print(f"  {year}: {percent:.1f}%")
    
    plt.figure(figsize=(10, 6))
    chronic_by_year.plot(kind='bar')
    plt.title('Chronic Homelessness Percentage by Year')
    plt.xlabel('Year')
    plt.ylabel('Percentage of Enrollments')
    plt.tight_layout()
    plt.savefig('plots/chronic_homelessness_by_year.png')
    
    # Outcomes for chronic homeless clients
    chronic_outcomes = enrollments_with_history[
        (enrollments_with_history['IsChronicHomeless'] == True) & 
        (enrollments_with_history['ExitDate'].notna())
    ]['DestinationCategory'].value_counts(normalize=True) * 100
    
    non_chronic_outcomes = enrollments_with_history[
        (enrollments_with_history['IsChronicHomeless'] == False) & 
        (enrollments_with_history['ExitDate'].notna())
    ]['DestinationCategory'].value_counts(normalize=True) * 100
    
    print("\nDESTINATION OUTCOMES FOR CHRONIC VS. NON-CHRONIC HOMELESS:")
    
    print("  Chronic Homeless Outcomes:")
    for dest, percent in chronic_outcomes.items():
        print(f"    - {dest}: {percent:.1f}%")
    
    print("\n  Non-Chronic Homeless Outcomes:")
    for dest, percent in non_chronic_outcomes.items():
        print(f"    - {dest}: {percent:.1f}%")
    
    # Create comparison plot
    outcomes_df = pd.DataFrame({
        'Chronic': chronic_outcomes,
        'Non-Chronic': non_chronic_outcomes
    }).fillna(0)
    
    plt.figure(figsize=(12, 8))
    outcomes_df.plot(kind='bar')
    plt.title('Destination Outcomes: Chronic vs. Non-Chronic Homeless')
    plt.xlabel('Destination Category')
    plt.ylabel('Percentage')
    plt.legend(title='Client Type')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.savefig('plots/chronic_vs_nonchronic_outcomes.png')
    
    return {
        'chronic_count': chronic_count,
        'chronic_by_project': chronic_by_project,
        'chronic_by_year': chronic_by_year,
        'chronic_outcomes': chronic_outcomes,
        'non_chronic_outcomes': non_chronic_outcomes
    }

# ==========================================
# LENGTH OF STAY ANALYSIS
# ==========================================
def analyze_length_of_stay():
    """
    Analyze patterns in length of stay across programs
    """
    print("\n===== LENGTH OF STAY ANALYSIS =====\n")
    
    # Filter to exits only
    exits = enrollments[enrollments['ExitDate'].notna()].copy()
    
    # Calculate length of stay
    exits['LengthOfStay'] = (exits['ExitDate'] - exits['EntryDate']).dt.days
    
    # Overall length of stay statistics
    print("OVERALL LENGTH OF STAY STATISTICS (DAYS):")
    los_stats = exits['LengthOfStay'].describe()
    for stat, value in los_stats.items():
        print(f"  {stat}: {value:.1f}")
    
    # Length of stay by project type
    los_by_project = exits.groupby('ProjectType')['LengthOfStay'].agg(['mean', 'median', 'count'])
    
    print("\nLENGTH OF STAY BY PROJECT TYPE (DAYS):")
    for project_type, stats in los_by_project.iterrows():
        project_name = {
            0: 'Emergency Shelter - Entry Exit',
            1: 'Emergency Shelter - Night-by-Night',
            2: 'Transitional Housing',
            3: 'PH - Permanent Supportive Housing',
            13: 'PH - Rapid Re-Housing'
        }.get(project_type, f'Other ({project_type})')
        
        print(f"  {project_name}:")
        print(f"    - Average: {stats['mean']:.1f} days")
        print(f"    - Median: {stats['median']:.1f} days")
        print(f"    - Count: {stats['count']} exits")
    
    # Visualize length of stay by project type
    plt.figure(figsize=(12, 6))
    sns.boxplot(x='ProjectType', y='LengthOfStay', data=exits)
    plt.title('Length of Stay by Project Type')
    plt.xlabel('Project Type')
    plt.ylabel('Days')
    plt.xticks([0, 1, 2, 3, 4], 
              ['ES - Entry Exit', 'ES - Night-by-Night', 'Transitional Housing', 
               'Permanent Supportive Housing', 'Rapid Re-Housing'])
    plt.tight_layout()
    plt.savefig('plots/length_of_stay_by_project.png')
    
    # Length of stay distribution
    plt.figure(figsize=(12, 6))
    sns.histplot(exits['LengthOfStay'], bins=30, kde=True)
    plt.title('Length of Stay Distribution (All Projects)')
    plt.xlabel('Days')
    plt.ylabel('Frequency')
    plt.axvline(exits['LengthOfStay'].median(), color='red', linestyle='--', 
               label=f'Median: {exits["LengthOfStay"].median():.0f} days')
    plt.legend()
    plt.tight_layout()
    plt.savefig('plots/length_of_stay_distribution.png')
    
    # Length of stay by exit destination
    los_by_destination = exits.groupby('DestinationCategory')['LengthOfStay'].agg(['mean', 'median', 'count'])
    
    print("\nLENGTH OF STAY BY EXIT DESTINATION (DAYS):")
    for dest, stats in los_by_destination.iterrows():
        print(f"  {dest}:")
        print(f"    - Average: {stats['mean']:.1f} days")
        print(f"    - Median: {stats['median']:.1f} days")
        print(f"    - Count: {stats['count']} exits")
    
    # Length of stay by year
    exits['ExitYear'] = exits['ExitDate'].dt.year
    los_by_year = exits.groupby('ExitYear')['LengthOfStay'].agg(['mean', 'median', 'count'])
    
    print("\nLENGTH OF STAY TRENDS BY YEAR (DAYS):")
    for year, stats in los_by_year.iterrows():
        print(f"  {year}:")
        print(f"    - Average: {stats['mean']:.1f} days")
        print(f"    - Median: {stats['median']:.1f} days")
        print(f"    - Count: {stats['count']} exits")
    
    plt.figure(figsize=(10, 6))
    los_by_year[['mean', 'median']].plot(kind='bar')
    plt.title('Length of Stay Trends by Year')
    plt.xlabel('Year')
    plt.ylabel('Days')
    plt.legend(title='Measure')
    plt.tight_layout()
    plt.savefig('plots/length_of_stay_by_year.png')
    
    # Success by length of stay (PH destination vs. length quartiles)
    exits['LOSQuartile'] = pd.qcut(exits['LengthOfStay'], 4, labels=['Q1 (Shortest)', 'Q2', 'Q3', 'Q4 (Longest)'])
    
    success_by_los = exits.groupby('LOSQuartile').apply(
        lambda x: (x['DestinationCategory'] == 'Permanent Housing').mean() * 100
    )
    
    print("\nPERMANENT HOUSING SUCCESS RATE BY LENGTH OF STAY QUARTILE:")
    for quartile, success_rate in success_by_los.items():
        print(f"  {quartile}: {success_rate:.1f}%")
    
    plt.figure(figsize=(10, 6))
    success_by_los.plot(kind='bar')
    plt.title('Permanent Housing Success Rate by Length of Stay Quartile')
    plt.xlabel('Length of Stay Quartile')
    plt.ylabel('Percentage to Permanent Housing')
    plt.tight_layout()
    plt.savefig('plots/success_by_length_of_stay.png')
    
    return {
        'los_stats': los_stats,
        'los_by_project': los_by_project,
        'los_by_destination': los_by_destination,
        'los_by_year': los_by_year,
        'success_by_los': success_by_los
    }

# ==========================================
# MAIN ANALYSIS EXECUTION
# ==========================================
def run_recidivism_analyses():
    print("HMIS RECIDIVISM AND PATTERNS ANALYSIS")
    print("=====================================\n")
    
    # Run all analyses
    recidivism_data = analyze_recidivism()
    chronic_data = analyze_chronic_homelessness()
    los_data = analyze_length_of_stay()
    
    print("\n===== ANALYSIS COMPLETE =====")
    print("Additional plots have been saved to the 'plots' directory")
    
    return {
        'recidivism_data': recidivism_data,
        'chronic_data': chronic_data,
        'los_data': los_data
    }

# Run the analysis
if __name__ == "__main__":
    results = run_recidivism_analyses()